function [sol, n_sol, n_sim, has_converged, info] = get_solution(solver_name, solver_param, optim)
%GET_SOLUTION Parse and scale the input variables, generates the initial points.
%   [sol, n_sol, n_sim, has_converged, info] = GET_SOLUTION(solver_name, solver_param, optim)
%   solver_name - name of the solver (string)
%       'brute_force' - test all the initial points, nothing more
%       'genetic_single_obj' - MATLAB genetic algoritm 'ga'
%       'genetic_multi_obj' - MATLAB genetic algoritm 'gamultiobj'
%   solver_param - struct with the solver data (struct)
%       solver_param.fct_solve - function computing the solution from the inputs (function handle)
%       solver_param.n_split - maximum number of solution evaluated in one vectorized call (integer)
%       solver_param.fct_valid - determine if a solution is valid to save memory (function handle)
%       solver_param - description of the additional field  (solver_name is 'brute_force')




%   optim - struct with the parsed variables (struct)
%      optim.lb - array containing the lower bounds of the variables (array of float)
%      optim.ub - array containing the upper bounds of the variables (array of float)
%      optim.int_con - array containing the index of the integer variables (array of integer)
%      optim.input - struct containing the constant (non-optimized) variables (array of integer)
%      optim.x0 - matrix containing the scaled initial points (matrix of float)
%      optim.var_scale - cell containing the function to unscale the variables (cell of struct)
%         optim.var_scale{i}.name - name of the variable (string)
%         optim.var_scale{i}.fct_unscale - function for unscaling the variables (function handle)
%   sol - solution data (struct of arrays)
%   n_sol - number points contained in the solution (integer)
%   n_sim - number of computed points during the optimization procedure (integer)
%   has_converged - return status of the algorithm (boolean)
%   info - information from the solver about the convergence (struct)
%
%   This function performs optimization with different solvers.
%   Please note that the 'genetic_multi_obj' cannot deal with integer variables.
%
%   See also GET_OPTIM, GET_PRE_PROC, GET_SOLVE_SOL, GET_SOLVE_OBJ, GA GAMULTIOBJ.

%   Thomas Guillod.
%   2020 - BSD License.




switch solver_name
    case 'brute_force'
        [sol, n_sol, has_converged, n_sim, info] = get_optim_brute(solver_param, optim);
    case 'genetic_single_obj'
        [sol, n_sol, has_converged, n_sim, info] = get_optim_ga(solver_param, optim);
    case 'genetic_multi_obj'
        [sol, n_sol, has_converged, n_sim, info] = get_optim_gamultiobj(solver_param, optim);
    otherwise
        error('invalid data')
end

end

function [sol, n_sol, has_converged, n_sim, info] = get_optim_brute(solver_param, optim)

% extract
fct_solve = solver_param.fct_solve;
fct_valid = solver_param.fct_valid;
fct_best = solver_param.fct_best;
n_split = solver_param.n_split;
input = optim.input;
var_scale = optim.var_scale;
x0 = optim.x0;

% run
[sol, n_sol] = get_solve_sol(x0, input, var_scale, fct_solve, fct_valid, n_split);

% get bests
idx_valid = fct_best(sol, n_sol);
sol = get_struct_idx(sol, idx_valid);
n_sol = nnz(idx_valid);
n_sim = size(x0, 1);

% info
has_converged = true;
info = struct();

end

function [sol, n_sol, has_converged, n_sim, info] = get_optim_ga(solver_param, optim)

% extract
fct_solve = solver_param.fct_solve;
fct_valid = solver_param.fct_valid;
fct_obj = solver_param.fct_obj;
n_split = solver_param.n_split;
options = solver_param.options;
input = optim.input;
var_scale = optim.var_scale;
x0 = optim.x0;
lb = optim.lb;
ub = optim.ub;
int_con = optim.int_con;

% merge
fct_optim_tmp = @(x) get_solve_obj(x, input, var_scale, fct_solve, fct_valid, fct_obj, n_split);
n_var = size(x0, 2);

% options
options = optimoptions(options, 'InitialPopulation', x0);
options = optimoptions(options, 'OutputFcn', @output_fct);
options = optimoptions(options, 'Vectorized', 'on');
options = optimoptions(options, 'Display', 'off');

% run
[x, f_val, exitflag, output] = ga(fct_optim_tmp, n_var, [], [], [], [], lb, ub, [], int_con, options);

% info
has_converged = (exitflag==1)&&all(isfinite(x))&&isfinite(f_val);
n_sim = output.funccount;
info.n_gen = output.generations;
info.message = output.message;

% extract
[sol, n_sol] = get_solve_sol(x, input, var_scale, fct_solve, fct_valid, n_split);

end

function [sol, n_sol, has_converged, n_sim, info] = get_optim_gamultiobj(solver_param, optim)

% extract
fct_solve = solver_param.fct_solve;
fct_valid = solver_param.fct_valid;
fct_obj = solver_param.fct_obj;
n_split = solver_param.n_split;
options = solver_param.options;
input = optim.input;
var_scale = optim.var_scale;
x0 = optim.x0;
lb = optim.lb;
ub = optim.ub;
int_con = optim.int_con;

% check
assert(isempty(int_con), 'invalid data')

% merge
fct_optim_tmp = @(x) get_solve_obj(x, input, var_scale, fct_solve, fct_valid, fct_obj, n_split);
n_var = size(x0, 2);

% x0
options = optimoptions(options, 'InitialPopulation', x0);
options = optimoptions(options, 'OutputFcn', @output_fct);
options = optimoptions(options, 'Vectorized', 'on');
options = optimoptions(options, 'UseParallel', true);
options = optimoptions(options, 'Display', 'off');

% run
[x, f_val, exitflag, output] = gamultiobj(fct_optim_tmp, n_var, [], [], [], [], lb, ub, [], options);

% info
has_converged = (exitflag==1)&&all(isfinite(x))&&isfinite(f_val);
n_sim = output.funccount;
info.n_gen = output.generations;
info.message = output.message;

% extract
[sol, n_sol] = get_solve_sol(x, input, var_scale, fct_solve, fct_valid, n_split);

end

function [state,options,optchanged] = output_fct(options, state, flag)

optchanged = false;
disp(['    ' flag ' / ' num2str(state.Generation) ' / ' num2str(state.FunEval)])

end